\section{Creating Regular Expressions}
\label{sec:regex}

\subsection{Problem}

You want to use a Vim regular expression, but don't know how they work.

For example, you want to search a document for a word that begins with a
vowel. 

\subsection{Solution}

\todo{Test all examples}

Vim allows you to use regular expressions (regexps) in many areas. The
Searching for any Word recipe, for example, explains how to search a file for
a regexp.

A regexp is a pattern that describes a string. We will use the
\verb"/{pattern}/" notation for describing patterns, and the
\textit{"\{string\}"} notation to represent the text the pattern is being tested
against. 

The simplest form of pattern is a literal string, which matches that exact
string. For example, \verb"/cow/" matches \textit{"cow"}, \textit{"Don't
have a cow"}, and \textit{"cower"}.

\todo{Describe '.'}

You can use character ranges to indicate that any one of the specified
characters are acceptable. For example \verb"/[cs]ow/" would match
\textit{"cow"}, \textit{"sow"}, and \textit{"undersow"}. 

If your range consists of alphabetically or numerically consecutive characters
you can specify the start character and end character seperated by a hyphen.
For example, to match \textit{b}, \textit{c}, \textit{d}, \textit{e}, or
\textit{f}, you can use
\verb"/[b-f]/". Or, an integer between 1 and 5: \verb"/[1-5]/".

\todo{Sidebar character classes}

You can invert character ranges so they match any character \textit{not}
specified. For example, \verb"/[^cs]ow/" matches any character that isn't a
\textit{c} or an \textit{s} followed by \textit{ow}, i.e.
\textit{"acknowledge"}, \textit{"I said "ow"!}, and \textit{"bellow"}.

Another concept of regexps is repetition. If you wanted to match strings
containing consectutive \textit{o}s followed by an \textit{i}, like
\textit{"cooing"} and \textit{"tattooist"}, you could use \verb"/ooi/". If
you wanted to abstract this pattern, however, to match one or more \textit{o}s
followed by an \textit{i}, you'd have a problem.

The solution is to precede the part of the pattern that can be repeated with a
'metacharacter' which specifies the type of repetition. For example,
\verb"/o\+i/", matches one or more \textit{o}s followed by an \textit{i}:
\textit{"abattoir"}, \textit{"cooing"}, and \textit{"oii"}.  The \verb"*"
metacharacter represents any number of ocuurences of the preceeding character,
so \verb"/o*i/" matches \textit{"zucchini"}, \textit{"boating"}, and
\textit{"zooimg"}. This time the \textit{o} is made optional. Given that it
starts the pattern it's actually unenessary; \verb"/i/" will match everything
that it matches. \todo{Explain properly} 

A more useful example is \verb"/[a-c]t*o\+i/" which matches either
\textit{a}, \textit{b}, or \textit{c} followed by any number of \textit{t}s,
followed by at least one \textit{o}, followed by an \textit{i}. The following
words satisfy the pattern: \textit{"tattooing"}, \textit{"coins"}, and
\textit{"limboing"}.  It may not be intutive that \textit{"tattooing"} would
match, so let's walk through it: The \textit{a} satisfies \verb"/[a-c]/",
the following two \textit{t}s match \verb"/t*/", the following two
\textit{o}s match \verb"/o\+/", then the \textit{i} matches \verb"/i/".

You can make a portion of the regexp optional (i.e. insiting that it matches 0
or 1 times) with \verb"\=". You can generalise this with the
\verb"\{min,max\}" notation which matches at least \textit{min} times, but no
more than \textit{max} times. For example, \verb"/[^a-c][a-c]\{2,4\}/" matches
\textit{"yachts"} (\textit{yac}), and \textit{"blabbed"} (\textit{labb}), but
doesn't match \textit{"cabbage"}.

Like character ranges, alternation allows you to specify a list of
alternatives that can match at a given point.  Whereas character ranges
specify sets of characters, alternation is used for sets of strings. For
example, \verb"/\(ing|ed\)/" matches the string \textit{ing} or the string
\textit{ed}, e.g.  \textit{"simpered"}, and \textit{"attacking"}. If you used
a character range here, e.g.  \verb"/[inged]/", the pattern would match any
string that contained an \textit{i}, an \textit{n}, a \textit{g}, an
\textit{e}, or a \textit{d}. i.e. it would match all the strings the
alternation approach does, but also many, many more.

All the patterns so far have been allowed to match at any point in the string.
That is to say, before Vim gives up on a match it will try applying the
pattern at every point in the text. You can change this behaviour by using
anchors: \verb"^" matches the start of a line, while \verb"$" matches the end.
So, \verb"/^\s\=\uo/" matches a line that begins with optional white space,
which is followed by an uppercase letter, which is followed by an \textit{o}.
The following strings will all match: \textit{" Popes are religious"},
\textit{"Roman"}, and \textit{"Soviet Union"}.

You can combine the two anchors to require that the whole line matches the
pattern. For example, \\\verb"/\^uo\(v|ma\).\+[rnt]\$/" will match \textit{"November"} and \textit{"Soviet"}, but will reject \textit{"Soviet
Union"} or \textit{"During November"}.

\subsection{Discussion}

The features described above are common to most regexp implementations. Vim
offers some extensions, though, that users familiar with other regexp
implementations may not be aware of.

By default regexps are case sensitive. That is to say \verb"/cow/" will not
match \textit{"Cow"}. You can make all patterns ignore case with \texttt{:set
ignorecase}. To change the case sensitivity for a particular pattern surround
the relevant portions with \verb"\c" (to ignore case from
this point on) and/or \verb"\C" to respect case from this
point on. For example, \verb"/\ccow/" matches \textit{"cow"},
\textit{"coW"}, and \textit{"Cow"}.  However,
\verb"/\cco\Cw/" matches \textit{"COw"} and
\textit{"cow"}, but not \textit{"COW"}. The \verb"\c" makes
the \textit{co} case insentitive, then the \verb"\C" makes
the \textit{w} case sensitive.  \todo{mention 'smartcase'?}

Some characters in a regexp have a special significance and don't match
themselves literally in the string. For example, \verb"/\^{}foo/" matches a
line starting with \textit{foo}; it doesn't match
\textit{"\textbackslash{}\^{}foo"}. To match a special character you need to
precede it with a backslash, For example \verb"\^" matches \textit{\^},
\verb"\$" matches \textit{\$}, \verb"\." matches \textit{.}, etc.  \todo{This
is far too vague}

\todo{mention '\n'. How?}

Vim supports backreferences which allow you to refer to part of a match later
in the same match. For example, \verb"/\([a-z]\)\1/" matches a lowercase
letter followed by the same character that just matched. This would match
\textit{"zoom"}, and \textit{"seeing"}. The parenthesised portion of the
pattern is a 'group', and the backreference (\verb"\{n}") refers to the
\textit{n}'th group. So, \verb"/\([a-z]\)\([a-z]\)\2\1/" matches two lowercase
letters, followed by the second one again, then the first one again.  This
would match strings like \textit{"abba"}.
